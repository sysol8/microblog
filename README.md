# Microblog

**Microblog** - Простой микроблог на базе React и FastAPI, демонстрирующий сквозной цикл разработки от клиентской части до серверного API и валидации данных.

## Основные возможности

- Лента постов с бесконечной прокруткой;
- Мультиавторство: каждый пост связан с профилем автора;
- Клиентский роутинг через React Router;
- Кастомизация профиля: пользователь может загружать аватар;
- Формы и валидация: демонстрируется работа с формами регистрации и авторизации пользователя, создания и редактирования постов;
- Авторизация и учёт прав: регистрация, логин, хранение токена, защита приватных маршрутов;

## Технологический стек

- Клиент: React с TypeScript, React Router, кастомные хуки, CSS Modules.
- Управление состоянием - Zustand.
- Сервер: FastAPI на Python, Pydantic для валидации, асинхронная запись в базу данных, asyncio для многопоточности.
- Хранение данных: SQLite для долговечного хранения постов и пользователей; облачное S3-хранилище для хранения загружаемых пользователями файлов.
- Сборка и конфигурация: Vite, ESLint, Prettier.

## Архитектура
- Инициализация приложения и роутинг в `main.tsx`;
- Папка `layouts` для страниц приложения: общий лейаут `AppLayout.tsx`, специфичные лейауты для отдельных маршрутов: `AuthLayout.tsx`, `PostsLayout.tsx`, `ProfileLayout.tsx`;
- Папка `components` для переиспользуемых UI-блоков `Modal.tsx`, `Alert.tsx`, `Toaster.tsx` и др.
- Стилизация компонентов при помощи CSS-модулей, которые хранятся рядом с компонентами в соответствующих папках. Стили компонентов практически полностью изолированы друг от друга, что позволяет редактировать их без вероятности "поломать" отображение;
- Папка `hooks` для кастомных хуков (`useAuth`, `useInfiniteScroll`, `usePosts`).
- Папка `api` с файлами, содержащими обёртку HTTP-клиента и наборы функций для работы с отдельными эндпоинтами эндпоинтами.
- `utils/utils.ts` для вспомогательных скриптов
- Серверная часть: `middleware` для работы с HTTP-запросами в режиме CORS при разработке, `models` для описания моделей данных в БД, `schemas` для определения схем данных, отправляемых на клиент, `main` - точка входа. Работа с постами реализована при помощи отдельного роута, что позволяет достигнуть низкой связанности модулей. Сам роут `posts` содержит CRUD-операции для работы с постами и взаимодействия с базой данных.

## Основные сущности
- `Post` - публикация в ленте. Содержит поля: 
   - `id` - уникальный идентификатор поста;
   - `author` - `id` пользователя, опубликовавшего пост; 
   - `content` - user-generated содержимое поста:
     - `textContent` - текстовое содержимое поста;
     - `attachments` - ссылки на облачное хранилище для прикрепленных к посту изображений.
   - `createdAt` - дата публикации; 
   - `isLiked` - булево поле, определяет, лайкнул ли конкретный пользователь данный пост; 
   - `likes` - общее количество лайков;
   - `watches` - общее количество просмотров поста;
   - `reposts` - общее количество репостов.
- `User` - пользователь. Содержит поля:
  - `id` - уникальный идентификатор пользователя; 
  - `name` - отображаемое имя пользователя;
  - `avatarUrl` - ссылка на аватар в облачном хранилище; 
  - `posts` - содержит всю информацию о постах пользователя:
    - `total` - общее количество постов;
    - `totalLikes` - общее количество лайков на постах пользователя;
    - `items` - сами посты, в т. ч. репосты.
  - `likes` - посты, лайкнутые пользователем; 
  - `createdAt` - дата регистрации;
  - `subscribers` - подписчики пользователя;
  - `subscriptions` - подписки пользователя.

## Компоненты
- `Post` - компонент поста. Принимает данные поста, а также экшены;
- `PostsList` - простой список постов. Рендерит новый `Post` для каждого элемента в массиве данных, приходящих с сервера;
- `PostForm` - форма для создания поста. Содержит текстовое поле, отображает лимит доступных для ввода символов. К форме можно прикреплять файлы-изображения с предпросмотром;
- `Modal` - общий компонент модального окна, который позволяет отображать динамический контент. Состояние `Modal` хранится в глобальном хранилище, описанном в `store/modalStore.ts`;
- `ImageModal` - связанный с модальным окном компонент (при этом не дублирующий его логику), отображающий галерею изображений с контролами для перелистывания (+ поддержка управления с клавиатуры).
- `AuthForm` - компонент, содержащий формы авторизации и регистрации в разных табах;
- `ImagePreview` - предпросмотр прикрепленных к форме изображений. Осуществляет проверку типа файла и возвращает превью картинки через `URL.createObjectURL()` или же `<span>` с названием файла, если файл не является изображением;
- `Alert` - компонент-уведомление. Принимает тип уведомления, от которого зависит внешний вид компонента, и отображаемое сообщение (ошибка, успех, предупреждение и др.);
- `Toaster` - компонент для отображения алертов в стэке;
-  Папка `layouts` содержит общие для лейаутов компоненты, например, `Header` и `Footer`;

## Лейауты
Приложение содержит 4 разных лейаута:
- `AppLayout` - главный, "абстрактный" лейаут приложения. Содержит провайдер модального окна, шапку и подвал страницы, а также `Outlet`, в котором рендерятся другие лейауты;
- `PostsLayout` отвечает за отображение основного контента приложения. Распаковывает данные и методы от хука `usePosts`. Массив постов и метод удаления поста отдает в компонент `PostsList`, метод добавления поста отдает в форму создания;
- `AuthLayout` содержит формы авторизации и регистрации. Пользователя редиректит на роут с данным лейаутом при попытке осуществить защищенные действия без авторизации: поставить лайк, сделать репост, посмотреть собственный профиль и др.;
- `ProfileLayout` отображает подробную информацию о пользователе.

## Хуки
- `usePosts`. Возвращает состояния загрузки и ошибки; массив постов; методы добавления и удаления поста.

## Управление состоянием
В приложении реализовано несколько хранилищ, которые при желании можно объединить в одно:
- `modalStore` управляет состоянием модального окна. Использование:
    ```
    modalStore.open(<YourComponent />);
    ```
  При этом закрытием окна можно управлять как из него самого (как реализовано в этом случае), так из любого другого компонента.
- `authStore` хранит текущего авторизованного пользователя, а также управляет методами логина и регистрации. Хранение текущего пользователя дает возможность реализовать защищенные роуты (Protected Routes) и действия (Protected Actions).
- `alertStore` предлагает крайне удобный способ менеджмента уведомлений. Использование:
    ``` typescript
  // config/alertMessages.ts
  // централизованно настраиваем сообщения для каждого вида ошибок
  
  export const alertMessages = {
      post: {
        addSuccess: "Пост успешно опубликован",
        addError: "Не удалось опубликовать пост",
      }
  }
  ```
  ``` typescript
  // config/alertConfig.ts
  // Вызываем методы стора (шорткаты), которые вызывают алерты определенных типов,
  // и передаем сообщения из объекта alertMessages
  
  import { useAlertStore } from '../store/alertStore.ts';
  import { alertMessages } from "./alertMessages.ts";

  export const alertConfig = {
    post: {
      onAddSuccess: () => useAlertStore.getState().success(alertMessages.post.addSuccess),
      onAddError: () => useAlertStore.getState().error(alertMessages.post.addError),
    }
  }
  ```
  ```typescript jsx
  // LikeButton.tsx
  const like = async () => {
    if (!user) {
      alertConfig.auth.onAuthRequired(); // обращаемся к конфигу, выбираем группу ошибок, вызываем алерт с конкретной ошибкой
      return;
    }
    
    // фунцию можно обернуть в withAlert(), возвращающую Promise<T>, 
    // и передавать так же из конфига нужные алерты (как успех, так и ошибку)
    await withAlert(
      async () => {
        await toggleLike(id);
        setLiked((prev) => !prev);
      }, {
        onSuccess: undefined,
        onError: (e: unknown) => {
          return;
        }
      }
    )
  };
  ```

## Установка и запуск

1. Склонировать репозиторий.
    ``` bash
    git clone https://github.com/sysol8/microblog.git
   ```
2. Установить зависимости клиента.
    ``` bash
    npm i
   ```
3. Установить зависимости бэкенда.
    ``` bash
   cd server
   python -m venv venv
   venv/scripts/activate
   pip install -r requirments.txt
   ```
   
4. Создать файл .env в корне проекта со следующим содержимым:
    ``` dotenv
    AWS_ENDPOINT_URL="your_aws_endpoint_url" // URL S3-совместимого хранилища
    AWS_ACCESS_KEY_ID="your_aws_access_key" // ключ доступа
    AWS_SECRET_ACCESS_KEY="your_aws_secret_access_key"
    AWS_DEFAULT_REGION="your_aws_default_region" // регион по умолчанию
    AWS_BUCKET_NAME="your_aws_bucket_name" // имя бакета

    DATABASE_URL="your_database_url"
    SQL_ECHO=1
    SQLITE_CHECK_SAME_THREAD=0

    JWT_SECRET="your_jwt_secret"
    JWT_ALG=HS256
    JWT_EXPIRE_MIN=60 // время жизни токена в минутах

    AUTH_COOKIE_NAME=auth
    CSRF_COOKIE_NAME=csrf_token
    SECURE_COOKIES=False
    AUTH_SAMESITE=lax
    AUTH_COOKIE_DOMAIN=""
   ```
    **Обратите внимание**, что в текущем виде в приложении не реализована обработка множества возможных ошибок на стороне сервера, поэтому некоторые действия могут осуществляться некорректно или неосуществляться вовсе, а также способны "положить" приложение. Например, без указания данных S3-совместимого хранилища будет недоступно изменение аватара профиля или прикрепление картинок к посту.


5. Запустить бэкенд.
    ``` bash
    fastapi dev
   ```
6. Запустить дев-сервер.
    ``` bash
   cd ..
   npm run dev
   ```
7. Перейти на http://localhost:5173. 

## Что можно добавить
- Реализовать систему комментариев и тредов под каждым постом;
- Реализовать систему уведомлений и обновления ленты в реальном времени через Server-Sent Events/Long-polling;
- Сделать светлую тему с переключателем и запоминанием выбора.
- Реализовать поиск по контенту и пользователям, фильтрацию ленты (теги, даты, популярность).
- Добавить пагинацию и сортировку как альтернативу бесконечной прокрутке.
- Разработать админ-панель для модерации постов и управления пользователями.
- Расширить авторизацию через OAuth;
- Добавить восстановление пароля с подтверждением по email;
- Настроить CI/CD-процессы, покрыть код тестами (unit, integration, e2e).
- Запаковать приложение в Docker-контейнеры и задеплоить в облако.
